window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "writedown", "modulename": "writedown", "type": "module", "doc": "<p></p>\n"}, {"fullname": "writedown.ast", "modulename": "writedown.ast", "type": "module", "doc": "<p></p>\n"}, {"fullname": "writedown.ast.ASTComponent", "modulename": "writedown.ast", "qualname": "ASTComponent", "type": "class", "doc": "<p>Represents an abstract syntax tree component.</p>\n\n<p>Contains properties and methods that other AST classes inherit from.</p>\n"}, {"fullname": "writedown.ast.ASTComponent.__init__", "modulename": "writedown.ast", "qualname": "ASTComponent.__init__", "type": "function", "doc": "<p>Initializes a new ASTComponent instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine)", "funcdef": "def"}, {"fullname": "writedown.ast.ASTComponent.sourceline", "modulename": "writedown.ast", "qualname": "ASTComponent.sourceline", "type": "variable", "doc": "<p>The source line from which this component is constructed.</p>\n"}, {"fullname": "writedown.ast.ASTComponent.source", "modulename": "writedown.ast", "qualname": "ASTComponent.source", "type": "variable", "doc": "<p>Returns the file path of the file that is the source of this component.</p>\n", "annotation": ": str"}, {"fullname": "writedown.ast.ASTComponent.lineno", "modulename": "writedown.ast", "qualname": "ASTComponent.lineno", "type": "variable", "doc": "<p>Returns the line number of the file that is the source of this component.</p>\n", "annotation": ": int"}, {"fullname": "writedown.ast.ASTComponent.raw", "modulename": "writedown.ast", "qualname": "ASTComponent.raw", "type": "variable", "doc": "<p>Returns the raw contents of the file line that is the source of this component.</p>\n", "annotation": ": str"}, {"fullname": "writedown.ast.ASTComponent.sourceinfo", "modulename": "writedown.ast", "qualname": "ASTComponent.sourceinfo", "type": "function", "doc": "<p>Returns a formatted information string representing the file path and \nline number of the file that is the source of this component, indented to denote\nthe level of this component in the document.</p>\n\n<p>Example:\n-- file.wd:123</p>\n", "signature": "(self, level: int = 0) -> str", "funcdef": "def"}, {"fullname": "writedown.ast.ASTAttribute", "modulename": "writedown.ast", "qualname": "ASTAttribute", "type": "class", "doc": "<p>Represents an abstract syntax tree attribute.</p>\n", "bases": "ASTComponent"}, {"fullname": "writedown.ast.ASTAttribute.__init__", "modulename": "writedown.ast", "qualname": "ASTAttribute.__init__", "type": "function", "doc": "<p>Initializes a new ASTAttribute instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine)", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode", "modulename": "writedown.ast", "qualname": "ASTNode", "type": "class", "doc": "<p>Represents an abstract syntax tree node.</p>\n", "bases": "ASTComponent"}, {"fullname": "writedown.ast.ASTNode.__init__", "modulename": "writedown.ast", "qualname": "ASTNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine)", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.parent", "modulename": "writedown.ast", "qualname": "ASTNode.parent", "type": "variable", "doc": "<p>This node's parent.</p>\n", "annotation": ": writedown.ast.ASTNode"}, {"fullname": "writedown.ast.ASTNode.nodes", "modulename": "writedown.ast", "qualname": "ASTNode.nodes", "type": "variable", "doc": "<p>Children of this node.</p>\n", "annotation": ": List[writedown.ast.ASTNode]"}, {"fullname": "writedown.ast.ASTNode.session", "modulename": "writedown.ast", "qualname": "ASTNode.session", "type": "variable", "doc": "<p>The session this node is associated with.</p>\n", "annotation": ": writedown.ast.SessionAttribute"}, {"fullname": "writedown.ast.ASTNode.session_template", "modulename": "writedown.ast", "qualname": "ASTNode.session_template", "type": "variable", "doc": "<p>Used to assign a child node's session when a child node is appended to this node.</p>\n\n<p>This is used during parsing to avoid assigning to or overwriting this node's session\nwhen this node's children belong to a session that this node does not.</p>\n", "annotation": ": writedown.ast.SessionAttribute"}, {"fullname": "writedown.ast.ASTNode.append", "modulename": "writedown.ast", "qualname": "ASTNode.append", "type": "function", "doc": "<p>Appends child to this node's children.</p>\n\n<p>If this node has a session template defined, it will be assigned as the child node's\nsession.  Otherwise, if this node has a session defined, it will be assigned as the\nchild node's session.</p>\n", "signature": "(self, child: writedown.ast.ASTNode)", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.extend", "modulename": "writedown.ast", "qualname": "ASTNode.extend", "type": "function", "doc": "<p>Appends each of the nodes in children to this node's children.</p>\n", "signature": "(self, children: Iterator[writedown.ast.ASTNode])", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.filter", "modulename": "writedown.ast", "qualname": "ASTNode.filter", "type": "function", "doc": "<p>Returns a generator of this node's descendents that func(child) returns True for. </p>\n\n<p>If recursive is True, all descendents will be processed; if False, only this node's\nimmediate children will be processed.</p>\n", "signature": "(\n    self,\n    func: Callable,\n    recursive: bool = True\n) -> Generator[writedown.ast.ASTNode, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.find", "modulename": "writedown.ast", "qualname": "ASTNode.find", "type": "function", "doc": "<p>Returns a generator of this node's descendents that are an instance of node_type.</p>\n\n<p>If recursive is True, all descendents will be processed; if False, only this node's\nimmediate children will be processed.</p>\n", "signature": "(\n    self,\n    node_type: type,\n    recursive: bool = True\n) -> Generator[writedown.ast.ASTNode, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.is_structural_node", "modulename": "writedown.ast", "qualname": "ASTNode.is_structural_node", "type": "function", "doc": "<p>Returns True if the node is an instance of a structural node (DocumentNode, ActNode, PartNode, ChapterNone, SceneNode, or SectionNode) and False if not.</p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.is_structural_leaf_node", "modulename": "writedown.ast", "qualname": "ASTNode.is_structural_leaf_node", "type": "function", "doc": "<p>Returns True if the node is the last instance of a structural node in its hierarchy and False if not.</p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.structural_lineage", "modulename": "writedown.ast", "qualname": "ASTNode.structural_lineage", "type": "function", "doc": "<p>Returns a list of the structural nodes in this node's lineage, including this node.</p>\n", "signature": "(self) -> List[writedown.ast.ASTNode]", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.structural_path", "modulename": "writedown.ast", "qualname": "ASTNode.structural_path", "type": "function", "doc": "<p>Returns a formatted string representing this node's lineage in the form of \"Grandparent &gt; Parent &gt; Self\".</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.wordcount", "modulename": "writedown.ast", "qualname": "ASTNode.wordcount", "type": "function", "doc": "<p>Returns the wordcount of all TextNodes in this node's hierarchy, including this node.</p>\n\n<p>If recursive is True, all descendents will be processed; if False, only this node\nwill be processed.</p>\n", "signature": "(self, recursive: bool = True) -> int", "funcdef": "def"}, {"fullname": "writedown.ast.ASTNode.charcount", "modulename": "writedown.ast", "qualname": "ASTNode.charcount", "type": "function", "doc": "<p>Returns the character count of all TextNodes in this node's hierarchy, including this node.</p>\n\n<p>If recursive is True, all descendents will be processed; if False, only this node\nwill be processed.</p>\n", "signature": "(self, recursive: bool = True) -> int", "funcdef": "def"}, {"fullname": "writedown.ast.ActNode", "modulename": "writedown.ast", "qualname": "ActNode", "type": "class", "doc": "<p>Represents an Act.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.ActNode.__init__", "modulename": "writedown.ast", "qualname": "ActNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    number: int = None,\n    title: str = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.ActNode.number", "modulename": "writedown.ast", "qualname": "ActNode.number", "type": "variable", "doc": "<p>The act number.</p>\n"}, {"fullname": "writedown.ast.ActNode.title", "modulename": "writedown.ast", "qualname": "ActNode.title", "type": "variable", "doc": "<p>The act title.</p>\n"}, {"fullname": "writedown.ast.AuthorNode", "modulename": "writedown.ast", "qualname": "AuthorNode", "type": "class", "doc": "<p>Represents an Author.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.AuthorNode.__init__", "modulename": "writedown.ast", "qualname": "AuthorNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine, name: str = None)", "funcdef": "def"}, {"fullname": "writedown.ast.AuthorNode.name", "modulename": "writedown.ast", "qualname": "AuthorNode.name", "type": "variable", "doc": "<p>The full author name.</p>\n"}, {"fullname": "writedown.ast.ChapterNode", "modulename": "writedown.ast", "qualname": "ChapterNode", "type": "class", "doc": "<p>Represents a Chapter.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.ChapterNode.__init__", "modulename": "writedown.ast", "qualname": "ChapterNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    number: int = None,\n    title: str = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.ChapterNode.number", "modulename": "writedown.ast", "qualname": "ChapterNode.number", "type": "variable", "doc": "<p>The chapter number.</p>\n"}, {"fullname": "writedown.ast.ChapterNode.title", "modulename": "writedown.ast", "qualname": "ChapterNode.title", "type": "variable", "doc": "<p>The chapter title.</p>\n"}, {"fullname": "writedown.ast.CharacterNode", "modulename": "writedown.ast", "qualname": "CharacterNode", "type": "class", "doc": "<p>Represents a Character.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.CharacterNode.__init__", "modulename": "writedown.ast", "qualname": "CharacterNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    name: str,\n    name_forms: Iterator[str] = None,\n    notes: str = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.CharacterNode.name", "modulename": "writedown.ast", "qualname": "CharacterNode.name", "type": "variable", "doc": "<p>The main character name.</p>\n"}, {"fullname": "writedown.ast.CharacterNode.name_forms", "modulename": "writedown.ast", "qualname": "CharacterNode.name_forms", "type": "variable", "doc": "<p>Alternative character names.</p>\n"}, {"fullname": "writedown.ast.CharacterNode.notes", "modulename": "writedown.ast", "qualname": "CharacterNode.notes", "type": "variable", "doc": "<p>Notes about the character.</p>\n"}, {"fullname": "writedown.ast.CommentNode", "modulename": "writedown.ast", "qualname": "CommentNode", "type": "class", "doc": "<p>Represents a Comment.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.CommentNode.__init__", "modulename": "writedown.ast", "qualname": "CommentNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    comment: str = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.CommentNode.comment", "modulename": "writedown.ast", "qualname": "CommentNode.comment", "type": "variable", "doc": "<p>The comment.</p>\n"}, {"fullname": "writedown.ast.DocumentNode", "modulename": "writedown.ast", "qualname": "DocumentNode", "type": "class", "doc": "<p>Represents a Document.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.DocumentNode.__init__", "modulename": "writedown.ast", "qualname": "DocumentNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "writedown.ast.LocationNode", "modulename": "writedown.ast", "qualname": "LocationNode", "type": "class", "doc": "<p>Represents a Location.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.LocationNode.__init__", "modulename": "writedown.ast", "qualname": "LocationNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    name: str = None,\n    geo_paths: Iterator[str] = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.LocationNode.name", "modulename": "writedown.ast", "qualname": "LocationNode.name", "type": "variable", "doc": "<p>The main location name.</p>\n"}, {"fullname": "writedown.ast.LocationNode.geo_paths", "modulename": "writedown.ast", "qualname": "LocationNode.geo_paths", "type": "variable", "doc": "<p>Additional geographic paths for the location.</p>\n"}, {"fullname": "writedown.ast.LocationNode.path", "modulename": "writedown.ast", "qualname": "LocationNode.path", "type": "function", "doc": "<p>Returns a string representing the full path of the location.</p>\n\n<p>Examples:\nMain Location Name\nMain Location Name, Geo 1 Name, Geo 2 Name</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "writedown.ast.PageBreakNode", "modulename": "writedown.ast", "qualname": "PageBreakNode", "type": "class", "doc": "<p>Represents a placeholder for a page break.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.PageBreakNode.__init__", "modulename": "writedown.ast", "qualname": "PageBreakNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine)", "funcdef": "def"}, {"fullname": "writedown.ast.PartNode", "modulename": "writedown.ast", "qualname": "PartNode", "type": "class", "doc": "<p>Represents a Part.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.PartNode.__init__", "modulename": "writedown.ast", "qualname": "PartNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    number: int = None,\n    title: str = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.PartNode.number", "modulename": "writedown.ast", "qualname": "PartNode.number", "type": "variable", "doc": "<p>The part number.</p>\n"}, {"fullname": "writedown.ast.PartNode.title", "modulename": "writedown.ast", "qualname": "PartNode.title", "type": "variable", "doc": "<p>The part title.</p>\n"}, {"fullname": "writedown.ast.PlaceNode", "modulename": "writedown.ast", "qualname": "PlaceNode", "type": "class", "doc": "<p>Represents a Place.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.PlaceNode.__init__", "modulename": "writedown.ast", "qualname": "PlaceNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    name: str = None,\n    geo_paths: Iterator[str] = None,\n    notes: str = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.PlaceNode.name", "modulename": "writedown.ast", "qualname": "PlaceNode.name", "type": "variable", "doc": "<p>The main place name.</p>\n"}, {"fullname": "writedown.ast.PlaceNode.geo_paths", "modulename": "writedown.ast", "qualname": "PlaceNode.geo_paths", "type": "variable", "doc": "<p>Additional geographic paths for the place.</p>\n"}, {"fullname": "writedown.ast.PlaceNode.notes", "modulename": "writedown.ast", "qualname": "PlaceNode.notes", "type": "variable", "doc": "<p>\"Notes about the place.</p>\n"}, {"fullname": "writedown.ast.PlaceNode.path", "modulename": "writedown.ast", "qualname": "PlaceNode.path", "type": "function", "doc": "<p>Returns a string representing the full path of the place.</p>\n\n<p>Examples:\nMain Place Name\nMain Place Name, Geo 1 Name, Geo 2 Name</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "writedown.ast.SceneNode", "modulename": "writedown.ast", "qualname": "SceneNode", "type": "class", "doc": "<p>Represents a Scene.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.SceneNode.__init__", "modulename": "writedown.ast", "qualname": "SceneNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    number: int = None,\n    title: str = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.SceneNode.number", "modulename": "writedown.ast", "qualname": "SceneNode.number", "type": "variable", "doc": "<p>The scene number.</p>\n"}, {"fullname": "writedown.ast.SceneNode.title", "modulename": "writedown.ast", "qualname": "SceneNode.title", "type": "variable", "doc": "<p>The scene title.</p>\n"}, {"fullname": "writedown.ast.SectionNode", "modulename": "writedown.ast", "qualname": "SectionNode", "type": "class", "doc": "<p>Represents a Section.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.SectionNode.__init__", "modulename": "writedown.ast", "qualname": "SectionNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    number: str = None,\n    title: str = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.SectionNode.number", "modulename": "writedown.ast", "qualname": "SectionNode.number", "type": "variable", "doc": "<p>The section number.</p>\n"}, {"fullname": "writedown.ast.SectionNode.title", "modulename": "writedown.ast", "qualname": "SectionNode.title", "type": "variable", "doc": "<p>The section title.</p>\n"}, {"fullname": "writedown.ast.SessionAttribute", "modulename": "writedown.ast", "qualname": "SessionAttribute", "type": "class", "doc": "<p>Represents a Session.</p>\n", "bases": "ASTAttribute"}, {"fullname": "writedown.ast.SessionAttribute.__init__", "modulename": "writedown.ast", "qualname": "SessionAttribute.__init__", "type": "function", "doc": "<p>Initializes a new ASTAttribute instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    date: datetime.date,\n    target: int,\n    name: str\n)", "funcdef": "def"}, {"fullname": "writedown.ast.SessionAttribute.date", "modulename": "writedown.ast", "qualname": "SessionAttribute.date", "type": "variable", "doc": "<p>The session date.</p>\n"}, {"fullname": "writedown.ast.SessionAttribute.target", "modulename": "writedown.ast", "qualname": "SessionAttribute.target", "type": "variable", "doc": "<p>The session target wordcount.</p>\n"}, {"fullname": "writedown.ast.SessionAttribute.name", "modulename": "writedown.ast", "qualname": "SessionAttribute.name", "type": "variable", "doc": "<p>The session name.</p>\n"}, {"fullname": "writedown.ast.StatusNode", "modulename": "writedown.ast", "qualname": "StatusNode", "type": "class", "doc": "<p>Represents the Status of a structural node.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.StatusNode.__init__", "modulename": "writedown.ast", "qualname": "StatusNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine, status: str)", "funcdef": "def"}, {"fullname": "writedown.ast.StatusNode.Statuses", "modulename": "writedown.ast", "qualname": "StatusNode.Statuses", "type": "class", "doc": "<p>Enumeration of valid statuses.</p>\n", "bases": "builtins.str, enum.Enum"}, {"fullname": "writedown.ast.StatusNode.Statuses.NEW", "modulename": "writedown.ast", "qualname": "StatusNode.Statuses.NEW", "type": "variable", "doc": "<p>Indicates that the associated section is new.</p>\n", "default_value": " = <Statuses.NEW: 'new'>"}, {"fullname": "writedown.ast.StatusNode.Statuses.DRAFT", "modulename": "writedown.ast", "qualname": "StatusNode.Statuses.DRAFT", "type": "variable", "doc": "<p>Indicates that the associated section is a draft.</p>\n", "default_value": " = <Statuses.DRAFT: 'draft'>"}, {"fullname": "writedown.ast.StatusNode.Statuses.REVISION", "modulename": "writedown.ast", "qualname": "StatusNode.Statuses.REVISION", "type": "variable", "doc": "<p>Indicates that the associated section is a revision.</p>\n", "default_value": " = <Statuses.REVISION: 'revision'>"}, {"fullname": "writedown.ast.StatusNode.Statuses.DONE", "modulename": "writedown.ast", "qualname": "StatusNode.Statuses.DONE", "type": "variable", "doc": "<p>Indicates that the associated section is done.</p>\n", "default_value": " = <Statuses.DONE: 'done'>"}, {"fullname": "writedown.ast.StatusNode.status", "modulename": "writedown.ast", "qualname": "StatusNode.status", "type": "variable", "doc": "<p>The status.</p>\n"}, {"fullname": "writedown.ast.TagNode", "modulename": "writedown.ast", "qualname": "TagNode", "type": "class", "doc": "<p>Represents a Tag.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.TagNode.__init__", "modulename": "writedown.ast", "qualname": "TagNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine, tags: List[str])", "funcdef": "def"}, {"fullname": "writedown.ast.TagNode.tags", "modulename": "writedown.ast", "qualname": "TagNode.tags", "type": "variable", "doc": "<p>The tags.</p>\n"}, {"fullname": "writedown.ast.TableOfContentsNode", "modulename": "writedown.ast", "qualname": "TableOfContentsNode", "type": "class", "doc": "<p>Represents a placeholder for a table of contents.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.TableOfContentsNode.__init__", "modulename": "writedown.ast", "qualname": "TableOfContentsNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine)", "funcdef": "def"}, {"fullname": "writedown.ast.TargetNode", "modulename": "writedown.ast", "qualname": "TargetNode", "type": "class", "doc": "<p>Represents a target wordcount for a structural node.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.TargetNode.__init__", "modulename": "writedown.ast", "qualname": "TargetNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine, value: int)", "funcdef": "def"}, {"fullname": "writedown.ast.TargetNode.value", "modulename": "writedown.ast", "qualname": "TargetNode.value", "type": "variable", "doc": "<p>The target wordcount.</p>\n"}, {"fullname": "writedown.ast.TextNode", "modulename": "writedown.ast", "qualname": "TextNode", "type": "class", "doc": "<p>Represents standard text.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.TextNode.__init__", "modulename": "writedown.ast", "qualname": "TextNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine, text: str)", "funcdef": "def"}, {"fullname": "writedown.ast.TextNode.text", "modulename": "writedown.ast", "qualname": "TextNode.text", "type": "variable", "doc": "<p>The text.</p>\n"}, {"fullname": "writedown.ast.TitleNode", "modulename": "writedown.ast", "qualname": "TitleNode", "type": "class", "doc": "<p>Represents the Title.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.TitleNode.__init__", "modulename": "writedown.ast", "qualname": "TitleNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine, text: str)", "funcdef": "def"}, {"fullname": "writedown.ast.TitleNode.text", "modulename": "writedown.ast", "qualname": "TitleNode.text", "type": "variable", "doc": "<p>The title text.</p>\n"}, {"fullname": "writedown.ast.TodoNode", "modulename": "writedown.ast", "qualname": "TodoNode", "type": "class", "doc": "<p>Represents a todo.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.TodoNode.__init__", "modulename": "writedown.ast", "qualname": "TodoNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(self, sourceline: writedown.sourceline.SourceLine, text: str)", "funcdef": "def"}, {"fullname": "writedown.ast.TodoNode.text", "modulename": "writedown.ast", "qualname": "TodoNode.text", "type": "variable", "doc": "<p>The todo text.</p>\n"}, {"fullname": "writedown.ast.UnmappedInstructionNode", "modulename": "writedown.ast", "qualname": "UnmappedInstructionNode", "type": "class", "doc": "<p>Represents an unmapped instruction.</p>\n\n<p>An unmapped instruction is any Writedown instruction not explicitly supported by the parser.\nFor example, if the input contained the instruction @notaninstruction, that would be\nconsidered an unmapped instruction. </p>\n\n<p>This feature exists to allow third party instructions to occur within input\nthat can be processed by third party tooling.</p>\n", "bases": "ASTNode"}, {"fullname": "writedown.ast.UnmappedInstructionNode.__init__", "modulename": "writedown.ast", "qualname": "UnmappedInstructionNode.__init__", "type": "function", "doc": "<p>Initializes a new ASTNode instance based on the given sourceline.</p>\n", "signature": "(\n    self,\n    sourceline: writedown.sourceline.SourceLine,\n    instruction: str = None,\n    text: str = None\n)", "funcdef": "def"}, {"fullname": "writedown.ast.UnmappedInstructionNode.instruction", "modulename": "writedown.ast", "qualname": "UnmappedInstructionNode.instruction", "type": "variable", "doc": "<p>The unmapped instruction.  For example: @notaninstruction</p>\n"}, {"fullname": "writedown.ast.UnmappedInstructionNode.text", "modulename": "writedown.ast", "qualname": "UnmappedInstructionNode.text", "type": "variable", "doc": "<p>Any text following the unmapped instruction.</p>\n"}, {"fullname": "writedown.buffer", "modulename": "writedown.buffer", "type": "module", "doc": "<p></p>\n"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer", "type": "class", "doc": "<p>Wraps a generator to performed buffered reading (and rereading) of generator-yielded content as well as index-based retrieval of content.</p>\n"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer.__init__", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, gen)", "funcdef": "def"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer.gen", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer.gen", "type": "variable", "doc": "<p>The wrapped generator.</p>\n"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer.buffer", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer.buffer", "type": "variable", "doc": "<p>The internal buffer.</p>\n"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer.offset", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer.offset", "type": "variable", "doc": "<p>The offset between indices between the internal buffer representation and the exposed representation.</p>\n"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer.consumed", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer.consumed", "type": "variable", "doc": "<p>The number of yields consumed from the generator.</p>\n"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer.truncate", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer.truncate", "type": "function", "doc": "<p>Truncates the contents of the internal buffer from the beginning of the buffer to the position specified.</p>\n\n<p>Used to eject fully consumed data that is no longer needed from memory.  Preserves an offset of the \ntruncated contents so that future requests to retrieve data by index do not need adjusting.</p>\n", "signature": "(self, pos: int) -> None", "funcdef": "def"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer.read", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer.read", "type": "function", "doc": "<p>Reads the next value(s) from the generator, as specified by the length to read.</p>\n", "signature": "(self, length: int = 1) -> None", "funcdef": "def"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer.valid_index", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer.valid_index", "type": "function", "doc": "<p>Returns True if the index can be requested (even if reading is required) and False if not.</p>\n", "signature": "(self, pos: int) -> bool", "funcdef": "def"}, {"fullname": "writedown.buffer.IndexedGeneratorBuffer.get", "modulename": "writedown.buffer", "qualname": "IndexedGeneratorBuffer.get", "type": "function", "doc": "<p>Returns (even if reading is required) the data at the specified index (makes a generator accessible like a list).</p>\n", "signature": "(self, pos: int) -> ~AnyStr", "funcdef": "def"}, {"fullname": "writedown.cli", "modulename": "writedown.cli", "type": "module", "doc": "<p></p>\n"}, {"fullname": "writedown.cli.CLI", "modulename": "writedown.cli", "qualname": "CLI", "type": "class", "doc": "<p></p>\n"}, {"fullname": "writedown.cli.CLI.__init__", "modulename": "writedown.cli", "qualname": "CLI.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.paths", "modulename": "writedown.cli", "qualname": "CLI.paths", "type": "variable", "doc": "<p>Used to track paths in shell mode</p>\n"}, {"fullname": "writedown.cli.CLI.create_argparser", "modulename": "writedown.cli", "qualname": "CLI.create_argparser", "type": "function", "doc": "<p></p>\n", "signature": "(self, in_shell: bool = False) -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.main", "modulename": "writedown.cli", "qualname": "CLI.main", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.parse_args", "modulename": "writedown.cli", "qualname": "CLI.parse_args", "type": "function", "doc": "<p></p>\n", "signature": "(self, input=None, in_shell=False)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.load_doc", "modulename": "writedown.cli", "qualname": "CLI.load_doc", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.blank_dash", "modulename": "writedown.cli", "qualname": "CLI.blank_dash", "type": "function", "doc": "<p></p>\n", "signature": "(self, value)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.delta_str", "modulename": "writedown.cli", "qualname": "CLI.delta_str", "type": "function", "doc": "<p></p>\n", "signature": "(self, delta)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.target_color", "modulename": "writedown.cli", "qualname": "CLI.target_color", "type": "function", "doc": "<p></p>\n", "signature": "(self, target, wordcount)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.indent", "modulename": "writedown.cli", "qualname": "CLI.indent", "type": "function", "doc": "<p></p>\n", "signature": "(self, level)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.truncate", "modulename": "writedown.cli", "qualname": "CLI.truncate", "type": "function", "doc": "<p></p>\n", "signature": "(self, text, length)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.row", "modulename": "writedown.cli", "qualname": "CLI.row", "type": "function", "doc": "<p></p>\n", "signature": "(self, *args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.cell", "modulename": "writedown.cli", "qualname": "CLI.cell", "type": "function", "doc": "<p></p>\n", "signature": "(self, text, width, align='left', color=None)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.shell", "modulename": "writedown.cli", "qualname": "CLI.shell", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.cat", "modulename": "writedown.cli", "qualname": "CLI.cat", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.about", "modulename": "writedown.cli", "qualname": "CLI.about", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.cd", "modulename": "writedown.cli", "qualname": "CLI.cd", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.characters", "modulename": "writedown.cli", "qualname": "CLI.characters", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.dir", "modulename": "writedown.cli", "qualname": "CLI.dir", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.edit", "modulename": "writedown.cli", "qualname": "CLI.edit", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.export_strip", "modulename": "writedown.cli", "qualname": "CLI.export_strip", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.export_draft", "modulename": "writedown.cli", "qualname": "CLI.export_draft", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.export_dump", "modulename": "writedown.cli", "qualname": "CLI.export_dump", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.export_text", "modulename": "writedown.cli", "qualname": "CLI.export_text", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.export_pdf", "modulename": "writedown.cli", "qualname": "CLI.export_pdf", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.info", "modulename": "writedown.cli", "qualname": "CLI.info", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.init_novel", "modulename": "writedown.cli", "qualname": "CLI.init_novel", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.locations", "modulename": "writedown.cli", "qualname": "CLI.locations", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.preview", "modulename": "writedown.cli", "qualname": "CLI.preview", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.pwd", "modulename": "writedown.cli", "qualname": "CLI.pwd", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.sessions", "modulename": "writedown.cli", "qualname": "CLI.sessions", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.status", "modulename": "writedown.cli", "qualname": "CLI.status", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.tags", "modulename": "writedown.cli", "qualname": "CLI.tags", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.targets", "modulename": "writedown.cli", "qualname": "CLI.targets", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.todo", "modulename": "writedown.cli", "qualname": "CLI.todo", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.wc", "modulename": "writedown.cli", "qualname": "CLI.wc", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.cli.CLI.version", "modulename": "writedown.cli", "qualname": "CLI.version", "type": "function", "doc": "<p></p>\n", "signature": "(self, args)", "funcdef": "def"}, {"fullname": "writedown.commands", "modulename": "writedown.commands", "type": "module", "doc": "<p></p>\n"}, {"fullname": "writedown.commands.Commands", "modulename": "writedown.commands", "qualname": "Commands", "type": "class", "doc": "<p>Commands for processing a Writedown document.</p>\n"}, {"fullname": "writedown.commands.Commands.__init__", "modulename": "writedown.commands", "qualname": "Commands.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, doc: writedown.ast.DocumentNode)", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.doc", "modulename": "writedown.commands", "qualname": "Commands.doc", "type": "variable", "doc": "<p>The DocumentNode.</p>\n"}, {"fullname": "writedown.commands.Commands.indent", "modulename": "writedown.commands", "qualname": "Commands.indent", "type": "function", "doc": "<p>Returns a string of dashes used to indent text at the specified level.</p>\n", "signature": "(self, level: int) -> str", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.characters", "modulename": "writedown.commands", "qualname": "Commands.characters", "type": "function", "doc": "<p>Returns a generator that, for each structural node in the current document, yields a tuple that contains:</p>\n\n<ol>\n<li>The level of the node</li>\n<li>The node itself</li>\n<li>A dictionary of all the characters occurring within the scope of the node which were defined by a Character instruction\nin the document.  The dictionary key is the CharacterNode and the value is the number of times the Character\nwas referenced.</li>\n</ol>\n\n<p>Example:\n(3, ChapterNode, { CharacterNode: 2, CharacterNode: 3 })</p>\n", "signature": "(\n    self\n) -> Generator[Tuple[int, writedown.ast.ASTNode, Dict[writedown.ast.CharacterNode, int]], NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.export_dump", "modulename": "writedown.commands", "qualname": "Commands.export_dump", "type": "function", "doc": "<p>Returns a generator that yields tuples of the form (level, node) for each node in the document.</p>\n", "signature": "(self) -> Generator[Tuple[int, writedown.ast.ASTNode], NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.export_draft", "modulename": "writedown.commands", "qualname": "Commands.export_draft", "type": "function", "doc": "<p>Renders a draft PDF of the document to filename.  If filename is None, the raw results are returned instead.</p>\n", "signature": "(self, filename: None) -> bytearray", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.export_text", "modulename": "writedown.commands", "qualname": "Commands.export_text", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> Generator[str, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.export_pdf", "modulename": "writedown.commands", "qualname": "Commands.export_pdf", "type": "function", "doc": "<p>Renders a PDF of the document to filename.  If filename is None, the raw results are returned instead.</p>\n", "signature": "(self, filename: None) -> bytearray", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.export_strip", "modulename": "writedown.commands", "qualname": "Commands.export_strip", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> Generator[str, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.info", "modulename": "writedown.commands", "qualname": "Commands.info", "type": "function", "doc": "<p>Returns a generator that yields strings of human-readable summary information about the current document.</p>\n", "signature": "(self) -> Generator[str, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.init_novel", "modulename": "writedown.commands", "qualname": "Commands.init_novel", "type": "function", "doc": "<p>Initializes a new project for writing a novel in the path specified.</p>\n", "signature": "(self, path: str) -> None", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.locations", "modulename": "writedown.commands", "qualname": "Commands.locations", "type": "function", "doc": "<p>Returns a generator that, for each structural node in the current document, yields a tuple that contains:</p>\n\n<ol>\n<li>The level of the node</li>\n<li>The node itself</li>\n<li>A dictionary of the locations occurring within the scope of the node.  The dictionary key is the \nLocationNode and the value is the resolved PlaceNode of the location if one exists in the document.</li>\n</ol>\n\n<p>Example:\n(3, ChapterNode, { LocationNode: None, LocationNode: PlaceNode })</p>\n", "signature": "(\n    self\n) -> Generator[Tuple[int, writedown.ast.ASTNode, Dict[writedown.ast.LocationNode, writedown.ast.PlaceNode]], NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.sessions", "modulename": "writedown.commands", "qualname": "Commands.sessions", "type": "function", "doc": "<p>Returns a generator that yields a dictionary of the following structure for each SessionNode encountered in the document:</p>\n\n<p>{\n    'session': session string representation,\n    'entry': the first node the session applies to,\n    'target': the session target wordcount,\n    'wordcount': the actual wordcount of the session scope,\n    'delta': the difference between the target and actual wordcounts\n}</p>\n", "signature": "(self) -> Generator[dict, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.status", "modulename": "writedown.commands", "qualname": "Commands.status", "type": "function", "doc": "<p>Returns a generator that, for each structural node in the current document, yields a tuple that contains:</p>\n\n<ol>\n<li>The level of the node</li>\n<li>The node itself</li>\n<li>The first status encountered in that node's immediate children.</li>\n</ol>\n\n<p>Example:\n(3, ChapterNode, StatusNode.Statuses)</p>\n", "signature": "(\n    self\n) -> Generator[Tuple[int, writedown.ast.ASTNode, writedown.ast.StatusNode.Statuses], NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.tags", "modulename": "writedown.commands", "qualname": "Commands.tags", "type": "function", "doc": "<p>Returns a generator that, for each structural node in the current document, yields a tuple that contains:</p>\n\n<ol>\n<li>The level of the node</li>\n<li>The node itself</li>\n<li>A set of the tags occurring within the scope of the node</li>\n</ol>\n\n<p>Example:\n(3, ChapterNode, ('one', 'two'))</p>\n", "signature": "(\n    self\n) -> Generator[Tuple[int, writedown.ast.ASTNode, Set[str]], NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.targets", "modulename": "writedown.commands", "qualname": "Commands.targets", "type": "function", "doc": "<p>Returns a generator that, for each structural node in the current document, yields a tuple that contains:</p>\n\n<ol>\n<li>The level of the node</li>\n<li>The node itself</li>\n<li>The target wordcount</li>\n<li>The actual wordcount</li>\n<li>The delta wordcount (difference between target and actual)</li>\n</ol>\n\n<p>Example:\n(3, ChapterNode, 1000, 750, 250)</p>\n", "signature": "(\n    self\n) -> Generator[Tuple[int, writedown.ast.ASTNode, int, int, int], NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.todo", "modulename": "writedown.commands", "qualname": "Commands.todo", "type": "function", "doc": "<p>Returns a generator that, for each TodoNode in the current document, yields a tuple that contains:</p>\n\n<ol>\n<li>The level of the node</li>\n<li>The node itself</li>\n<li>A boolean value indicating if this node is a contextual node or not</li>\n</ol>\n\n<p>If context is False, only TodoNodes will be yielded.\nIf context is True, the node immediately preceding and the node immediately proceeding each TodoNode\nwill be yielded in addition to each TodoNode.</p>\n\n<p>Examples:\n(4, TodoNode, False)</p>\n\n<p>With context set to True:\n(4, TextNode, True)\n(4, TodoNode, False)\n(4, TextNode, True)</p>\n", "signature": "(\n    self,\n    context: bool = False\n) -> Generator[Tuple[int, writedown.ast.ASTNode, bool], NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.commands.Commands.wc", "modulename": "writedown.commands", "qualname": "Commands.wc", "type": "function", "doc": "<p>Returns a generator that, for each structural node in the current document, yields a tuple that contains the following\naggregated calculations based on industry standard averages:</p>\n\n<ol>\n<li>The level of the node</li>\n<li>The node itself</li>\n<li>A tuple representing reading time (based on 275 wpm):\n<ol>\n<li>Hours</li>\n<li>Minutes</li>\n<li>Seconds</li>\n</ol></li>\n<li>The page count (based on 300 words per page)</li>\n<li>The wordcount</li>\n<li>The character count</li>\n</ol>\n\n<p>Example:\n(3, ChapterNode, (0, 2, 1), 2, 555, 3127)</p>\n", "signature": "(\n    self\n) -> Generator[Tuple[int, writedown.ast.ASTNode, Tuple[int, int, int], float, int, int], NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.parser", "modulename": "writedown.parser", "type": "module", "doc": "<p></p>\n"}, {"fullname": "writedown.parser.SequenceWarning", "modulename": "writedown.parser", "qualname": "SequenceWarning", "type": "class", "doc": "<p>Used to warn about issues in structural node sequences (e.g., out of sequence Chapter numbers).</p>\n", "bases": "builtins.UserWarning"}, {"fullname": "writedown.parser.Parser", "modulename": "writedown.parser", "qualname": "Parser", "type": "class", "doc": "<p>A parser for Writedown content.</p>\n"}, {"fullname": "writedown.parser.Parser.__init__", "modulename": "writedown.parser", "qualname": "Parser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences: Dict[str, int] = None)", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.sequences", "modulename": "writedown.parser", "qualname": "Parser.sequences", "type": "variable", "doc": "<p>A dict for tracking sequence numbers for structural nodes such as Chapters and Scenes.</p>\n"}, {"fullname": "writedown.parser.Parser.sequence_key", "modulename": "writedown.parser", "qualname": "Parser.sequence_key", "type": "function", "doc": "<p>Returns a dict key for tracking sequences for the given structural type in the context of the given node holder.</p>\n\n<p>The structural_type is a string because this method should be invoked prior to creation of the corresponding ASTNode instance.</p>\n", "signature": "(self, node_holder: writedown.ast.ASTNode, structural_type: str) -> str", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.next_sequence", "modulename": "writedown.parser", "qualname": "Parser.next_sequence", "type": "function", "doc": "<p>Returns the next sequence number for the given structural type in the context of the given node holder.</p>\n\n<p>The structural_type is a string because this method should be invoked prior to creation of the corresponding ASTNode instance.</p>\n", "signature": "(self, node_holder: writedown.ast.ASTNode, structural_type: str) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.set_sequence", "modulename": "writedown.parser", "qualname": "Parser.set_sequence", "type": "function", "doc": "<p>Sets the current sequence number for the given structural type in the context of the given node holder.</p>\n\n<p>The structural_type is a string because this method should be invoked prior to creation of the corresponding ASTNode instance.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    structural_type: str,\n    number: int\n) -> None", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.get_or_set_sequence", "modulename": "writedown.parser", "qualname": "Parser.get_or_set_sequence", "type": "function", "doc": "<p>Gets the next or sets the current sequence number for the given structrual type in the context of the given node holder\nbased on the value of number.</p>\n\n<p>If number is None, the next sequence number is retrieved.  Otherwise, number is set as the current sequence number.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    structural_type: str,\n    number: int\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.strip_instruction", "modulename": "writedown.parser", "qualname": "Parser.strip_instruction", "type": "function", "doc": "<p>Removes leading Writedown instructions from a string.</p>\n\n<p>For example, \"@chapter One\" would be returned as \"One\".</p>\n", "signature": "(self, str: str) -> str", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.is_instruction", "modulename": "writedown.parser", "qualname": "Parser.is_instruction", "type": "function", "doc": "<p>Returns True if the given text starts with the given Writedown instruction token.</p>\n", "signature": "(self, text: str, token: writedown.tokens.Tokens) -> bool", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.get_instruction", "modulename": "writedown.parser", "qualname": "Parser.get_instruction", "type": "function", "doc": "<p>Returns the leading Writedown instruction token for the given string; returns None if one is not present.</p>\n\n<p>For example, \"@chapter One\" would return \"@chapter\".</p>\n", "signature": "(self, str: str) -> str", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.set_session_template", "modulename": "writedown.parser", "qualname": "Parser.set_session_template", "type": "function", "doc": "<p>Sets the session template for the given node holder and all its ancestors.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    session_template: writedown.ast.SessionAttribute\n) -> None", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.parse", "modulename": "writedown.parser", "qualname": "Parser.parse", "type": "function", "doc": "<p>Parses the supplied lines for Writedown markup, starting and ending at the provided index positions\n(inclusive and exclusive, respectively), in the context of the given node holder.  </p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0,\n    end: int = None\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.parse_str", "modulename": "writedown.parser", "qualname": "Parser.parse_str", "type": "function", "doc": "<p>Parses the provided string and returns a list of ASTNodes.</p>\n", "signature": "(self, str: str) -> List[writedown.ast.ASTNode]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.parse_file", "modulename": "writedown.parser", "qualname": "Parser.parse_file", "type": "function", "doc": "<p>Parses the contents of the provided file path and returns a list of ASTNodes.</p>\n", "signature": "(self, path: str) -> List[writedown.ast.ASTNode]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.parse_files", "modulename": "writedown.parser", "qualname": "Parser.parse_files", "type": "function", "doc": "<p>Parses the contents of the provided file paths and returns a list of ASTNodes.</p>\n", "signature": "(self, paths: Iterable[str]) -> List[writedown.ast.ASTNode]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.parse_path", "modulename": "writedown.parser", "qualname": "Parser.parse_path", "type": "function", "doc": "<p>Parses the contents of the files matching the provided glob path and returns a list of ASTNodes.</p>\n", "signature": "(\n    self,\n    glob_path: str = None,\n    recursive: bool = True\n) -> List[writedown.ast.ASTNode]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.parse_paths", "modulename": "writedown.parser", "qualname": "Parser.parse_paths", "type": "function", "doc": "<p>Parses the contents of the files matching the provided glob paths and returns a list of ASTNodes.</p>\n", "signature": "(\n    self,\n    glob_paths: Iterable[str] = None,\n    recursive: bool = True\n) -> List[writedown.ast.ASTNode]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.parse_doc", "modulename": "writedown.parser", "qualname": "Parser.parse_doc", "type": "function", "doc": "<p>Parses the content of the provided string and returns a DocumentNode.</p>\n", "signature": "(self, str: str) -> writedown.ast.DocumentNode", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.parse_doc_from_path", "modulename": "writedown.parser", "qualname": "Parser.parse_doc_from_path", "type": "function", "doc": "<p>Parses the contents of the files matching the provided glob path and returns a DocumentNode.</p>\n", "signature": "(\n    self,\n    glob_path: str = None,\n    recursive: bool = True\n) -> writedown.ast.DocumentNode", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.parse_doc_from_paths", "modulename": "writedown.parser", "qualname": "Parser.parse_doc_from_paths", "type": "function", "doc": "<p>Parses the contents of the files matching the provided glob paths and returns a DocumentNode.</p>\n", "signature": "(\n    self,\n    glob_paths: Iterable[str] = None,\n    recursive: bool = True\n) -> writedown.ast.DocumentNode", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.read_iter", "modulename": "writedown.parser", "qualname": "Parser.read_iter", "type": "function", "doc": "<p>Returns a generator that yields instances of SourceLine from the provided source and line iterator.</p>\n", "signature": "(\n    self,\n    source: str,\n    iter: Iterable[str]\n) -> Generator[writedown.sourceline.SourceLine, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.read_str", "modulename": "writedown.parser", "qualname": "Parser.read_str", "type": "function", "doc": "<p>Returns a generator that yields SourceLines from the given string.</p>\n", "signature": "(\n    self,\n    str: str\n) -> Generator[writedown.sourceline.SourceLine, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.read_file", "modulename": "writedown.parser", "qualname": "Parser.read_file", "type": "function", "doc": "<p>Reads the given path and yields SourceLines for each line read.</p>\n", "signature": "(\n    self,\n    path: str\n) -> Generator[writedown.sourceline.SourceLine, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.read_path", "modulename": "writedown.parser", "qualname": "Parser.read_path", "type": "function", "doc": "<p>Reads files matching the given path and yields SourceLines for each line read.</p>\n", "signature": "(\n    self,\n    glob_path: str = None,\n    recursive: bool = True\n) -> Generator[writedown.sourceline.SourceLine, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.read_paths", "modulename": "writedown.parser", "qualname": "Parser.read_paths", "type": "function", "doc": "<p>Reads files matching the given paths and yields SourceLines for each line read.</p>\n", "signature": "(\n    self,\n    glob_paths: Iterable[str] = None,\n    recursive: bool = True\n) -> Generator[writedown.sourceline.SourceLine, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.parser.Parser.list_path", "modulename": "writedown.parser", "qualname": "Parser.list_path", "type": "function", "doc": "<p>Returns a generator that yields the names of files matching the given glob pattern path.</p>\n\n<p>If a glob pattern path is not provided or if the glob pattern path resolves to a directory, \nthe following glob patterns will be attempted, and the first successful pattern will be used:</p>\n\n<pre><code>index.wd\n**/*.wd\n</code></pre>\n\n<p>Raises a ValueError if a non-directory path is specified and no files are matched.</p>\n", "signature": "(\n    self,\n    glob_path: str = None,\n    recursive: bool = True\n) -> Generator[str, NoneType, NoneType]", "funcdef": "def"}, {"fullname": "writedown.parser.ActParser", "modulename": "writedown.parser", "qualname": "ActParser", "type": "class", "doc": "<p>A parser for Writedown Act instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.ActParser.__init__", "modulename": "writedown.parser", "qualname": "ActParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.ActParser.parse", "modulename": "writedown.parser", "qualname": "ActParser.parse", "type": "function", "doc": "<p>Parses @act instructions starting at the specified position in the context of the node holder.  The first line must be an @act instruction.</p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.PartParser", "modulename": "writedown.parser", "qualname": "PartParser", "type": "class", "doc": "<p>A parser for Writedown Part instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.PartParser.__init__", "modulename": "writedown.parser", "qualname": "PartParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.PartParser.parse", "modulename": "writedown.parser", "qualname": "PartParser.parse", "type": "function", "doc": "<p>Parses @part instructions starting at the specified position in the context of the node holder.  The first line must be a @part instruction.</p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.ChapterParser", "modulename": "writedown.parser", "qualname": "ChapterParser", "type": "class", "doc": "<p>A parser for Writedown Chapter instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.ChapterParser.__init__", "modulename": "writedown.parser", "qualname": "ChapterParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.ChapterParser.parse", "modulename": "writedown.parser", "qualname": "ChapterParser.parse", "type": "function", "doc": "<p>Parses @chapter instructions starting at the specified position in the context of the node holder.  The first line must be a @chapter instruction.</p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.SceneParser", "modulename": "writedown.parser", "qualname": "SceneParser", "type": "class", "doc": "<p>A parser for Writedown Scene instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.SceneParser.__init__", "modulename": "writedown.parser", "qualname": "SceneParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.SceneParser.parse", "modulename": "writedown.parser", "qualname": "SceneParser.parse", "type": "function", "doc": "<p>Parses @scene instructions starting at the specified position in the context of the node holder.  The first line must be a @scene instruction.</p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.SectionParser", "modulename": "writedown.parser", "qualname": "SectionParser", "type": "class", "doc": "<p>A parser for Writedown Section instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.SectionParser.__init__", "modulename": "writedown.parser", "qualname": "SectionParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.SectionParser.parse", "modulename": "writedown.parser", "qualname": "SectionParser.parse", "type": "function", "doc": "<p>Parses @section instructions starting at the specified position in the context of the node holder.  The first line must be a @section instruction.</p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.CharacterParser", "modulename": "writedown.parser", "qualname": "CharacterParser", "type": "class", "doc": "<p>A parser for Writedown Character instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.CharacterParser.__init__", "modulename": "writedown.parser", "qualname": "CharacterParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.CharacterParser.parse", "modulename": "writedown.parser", "qualname": "CharacterParser.parse", "type": "function", "doc": "<p>Parses @character instructions starting at the specified position in the context of the node holder.  The first line must be a @character instruction.</p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.PlaceParser", "modulename": "writedown.parser", "qualname": "PlaceParser", "type": "class", "doc": "<p>A parser for Writedown Place instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.PlaceParser.__init__", "modulename": "writedown.parser", "qualname": "PlaceParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.PlaceParser.parse", "modulename": "writedown.parser", "qualname": "PlaceParser.parse", "type": "function", "doc": "<p>Parses @place instructions starting at the specified position in the context of the node holder.  The first line must be a @place instruction.</p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.LocationParser", "modulename": "writedown.parser", "qualname": "LocationParser", "type": "class", "doc": "<p>A parser for Writedown Location instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.LocationParser.__init__", "modulename": "writedown.parser", "qualname": "LocationParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.LocationParser.parse", "modulename": "writedown.parser", "qualname": "LocationParser.parse", "type": "function", "doc": "<p>Parses @location instructions starting at the specified position in the context of the node holder.  The first line must be a @location instruction.</p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.SessionParser", "modulename": "writedown.parser", "qualname": "SessionParser", "type": "class", "doc": "<p>A parser for Writedown Session instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.SessionParser.__init__", "modulename": "writedown.parser", "qualname": "SessionParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.SessionParser.parse", "modulename": "writedown.parser", "qualname": "SessionParser.parse", "type": "function", "doc": "<p>Do not use.</p>\n\n<p>Raises NotImplementedError.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.parser.SessionParser.get_session_node", "modulename": "writedown.parser", "qualname": "SessionParser.get_session_node", "type": "function", "doc": "<p>Returns a SessionAttribute parsed from the @session instruction in the given line.</p>\n", "signature": "(\n    self,\n    instruction_line: writedown.sourceline.SourceLine\n) -> writedown.ast.SessionAttribute", "funcdef": "def"}, {"fullname": "writedown.parser.CommentBlockParser", "modulename": "writedown.parser", "qualname": "CommentBlockParser", "type": "class", "doc": "<p>A parser for Writedown Comment Block instructions.</p>\n", "bases": "Parser"}, {"fullname": "writedown.parser.CommentBlockParser.__init__", "modulename": "writedown.parser", "qualname": "CommentBlockParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, sequences=None)", "funcdef": "def"}, {"fullname": "writedown.parser.CommentBlockParser.strip_comment_block_end", "modulename": "writedown.parser", "qualname": "CommentBlockParser.strip_comment_block_end", "type": "function", "doc": "<p></p>\n", "signature": "(self, text)", "funcdef": "def"}, {"fullname": "writedown.parser.CommentBlockParser.parse", "modulename": "writedown.parser", "qualname": "CommentBlockParser.parse", "type": "function", "doc": "<p>Parses @* ... <em>@ instructions starting at the specified position in the context of the node holder.  The first line must start with a @</em> instruction.</p>\n\n<p>Returns the (unprocessed) index from which subsequent parsing should resume, if any.</p>\n", "signature": "(\n    self,\n    node_holder: writedown.ast.ASTNode,\n    lines: writedown.buffer.IndexedGeneratorBuffer,\n    pos: int = 0\n) -> int", "funcdef": "def"}, {"fullname": "writedown.sourceline", "modulename": "writedown.sourceline", "type": "module", "doc": "<p></p>\n"}, {"fullname": "writedown.sourceline.SourceLine", "modulename": "writedown.sourceline", "qualname": "SourceLine", "type": "class", "doc": "<p>Contains information about a line of input.</p>\n"}, {"fullname": "writedown.sourceline.SourceLine.__init__", "modulename": "writedown.sourceline", "qualname": "SourceLine.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, source, lineno, content)", "funcdef": "def"}, {"fullname": "writedown.sourceline.SourceLine.source", "modulename": "writedown.sourceline", "qualname": "SourceLine.source", "type": "variable", "doc": "<p>The file path of the source, or 'string' if string input.</p>\n"}, {"fullname": "writedown.sourceline.SourceLine.lineno", "modulename": "writedown.sourceline", "qualname": "SourceLine.lineno", "type": "variable", "doc": "<p>The line number of this line.</p>\n"}, {"fullname": "writedown.sourceline.SourceLine.content", "modulename": "writedown.sourceline", "qualname": "SourceLine.content", "type": "variable", "doc": "<p>The content of the line.</p>\n"}, {"fullname": "writedown.tokens", "modulename": "writedown.tokens", "type": "module", "doc": "<p></p>\n"}, {"fullname": "writedown.tokens.Tokens", "modulename": "writedown.tokens", "qualname": "Tokens", "type": "class", "doc": "<p>An enumeration.</p>\n", "bases": "builtins.str, enum.Enum"}, {"fullname": "writedown.tokens.Tokens.ACT", "modulename": "writedown.tokens", "qualname": "Tokens.ACT", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.ACT: '@act'>"}, {"fullname": "writedown.tokens.Tokens.AUTHOR", "modulename": "writedown.tokens", "qualname": "Tokens.AUTHOR", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.AUTHOR: '@author'>"}, {"fullname": "writedown.tokens.Tokens.CHAPTER", "modulename": "writedown.tokens", "qualname": "Tokens.CHAPTER", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.CHAPTER: '@chapter'>"}, {"fullname": "writedown.tokens.Tokens.CHARACTER", "modulename": "writedown.tokens", "qualname": "Tokens.CHARACTER", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.CHARACTER: '@character'>"}, {"fullname": "writedown.tokens.Tokens.COMMENT", "modulename": "writedown.tokens", "qualname": "Tokens.COMMENT", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.COMMENT: '@comment'>"}, {"fullname": "writedown.tokens.Tokens.COMMENT_SHORTHAND", "modulename": "writedown.tokens", "qualname": "Tokens.COMMENT_SHORTHAND", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.COMMENT_SHORTHAND: '@#'>"}, {"fullname": "writedown.tokens.Tokens.COMMENT_BLOCK_START", "modulename": "writedown.tokens", "qualname": "Tokens.COMMENT_BLOCK_START", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.COMMENT_BLOCK_START: '@*'>"}, {"fullname": "writedown.tokens.Tokens.COMMENT_BLOCK_END", "modulename": "writedown.tokens", "qualname": "Tokens.COMMENT_BLOCK_END", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.COMMENT_BLOCK_END: '*@'>"}, {"fullname": "writedown.tokens.Tokens.END_SESSION", "modulename": "writedown.tokens", "qualname": "Tokens.END_SESSION", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.END_SESSION: '@endsession'>"}, {"fullname": "writedown.tokens.Tokens.EOF", "modulename": "writedown.tokens", "qualname": "Tokens.EOF", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.EOF: '@eof'>"}, {"fullname": "writedown.tokens.Tokens.INCLUDE", "modulename": "writedown.tokens", "qualname": "Tokens.INCLUDE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.INCLUDE: '@include'>"}, {"fullname": "writedown.tokens.Tokens.INSTRUCTION", "modulename": "writedown.tokens", "qualname": "Tokens.INSTRUCTION", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.INSTRUCTION: '@'>"}, {"fullname": "writedown.tokens.Tokens.LOCATION", "modulename": "writedown.tokens", "qualname": "Tokens.LOCATION", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.LOCATION: '@location'>"}, {"fullname": "writedown.tokens.Tokens.NEWLINE", "modulename": "writedown.tokens", "qualname": "Tokens.NEWLINE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.NEWLINE: '\\n'>"}, {"fullname": "writedown.tokens.Tokens.PAGEBREAK", "modulename": "writedown.tokens", "qualname": "Tokens.PAGEBREAK", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.PAGEBREAK: '@pagebreak'>"}, {"fullname": "writedown.tokens.Tokens.PART", "modulename": "writedown.tokens", "qualname": "Tokens.PART", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.PART: '@part'>"}, {"fullname": "writedown.tokens.Tokens.PLACE", "modulename": "writedown.tokens", "qualname": "Tokens.PLACE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.PLACE: '@place'>"}, {"fullname": "writedown.tokens.Tokens.SCENE", "modulename": "writedown.tokens", "qualname": "Tokens.SCENE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.SCENE: '@scene'>"}, {"fullname": "writedown.tokens.Tokens.SECTION", "modulename": "writedown.tokens", "qualname": "Tokens.SECTION", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.SECTION: '@section'>"}, {"fullname": "writedown.tokens.Tokens.SESSION", "modulename": "writedown.tokens", "qualname": "Tokens.SESSION", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.SESSION: '@session'>"}, {"fullname": "writedown.tokens.Tokens.STATUS", "modulename": "writedown.tokens", "qualname": "Tokens.STATUS", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.STATUS: '@status'>"}, {"fullname": "writedown.tokens.Tokens.TABLE_OF_CONTENTS", "modulename": "writedown.tokens", "qualname": "Tokens.TABLE_OF_CONTENTS", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.TABLE_OF_CONTENTS: '@tableofcontents'>"}, {"fullname": "writedown.tokens.Tokens.TAG", "modulename": "writedown.tokens", "qualname": "Tokens.TAG", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.TAG: '@tag'>"}, {"fullname": "writedown.tokens.Tokens.TARGET", "modulename": "writedown.tokens", "qualname": "Tokens.TARGET", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.TARGET: '@target'>"}, {"fullname": "writedown.tokens.Tokens.TITLE", "modulename": "writedown.tokens", "qualname": "Tokens.TITLE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.TITLE: '@title'>"}, {"fullname": "writedown.tokens.Tokens.TOC", "modulename": "writedown.tokens", "qualname": "Tokens.TOC", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.TOC: '@toc'>"}, {"fullname": "writedown.tokens.Tokens.TODO", "modulename": "writedown.tokens", "qualname": "Tokens.TODO", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Tokens.TODO: '@todo'>"}, {"fullname": "writedown.util", "modulename": "writedown.util", "type": "module", "doc": "<p></p>\n"}, {"fullname": "writedown.util.pagecount", "modulename": "writedown.util", "qualname": "pagecount", "type": "function", "doc": "<p>Returns the estimated number of pages the given wordcount would produce using industry standard calculations.</p>\n", "signature": "(wordcount: int) -> float", "funcdef": "def"}, {"fullname": "writedown.util.reading_time", "modulename": "writedown.util", "qualname": "reading_time", "type": "function", "doc": "<p>Returns a tuple of the form (hours, minutes, seconds) representing the time it would take an adult to read the specified wordcount.</p>\n", "signature": "(wordcount: int) -> Tuple[int, int, int]", "funcdef": "def"}, {"fullname": "writedown.util.reading_time_str", "modulename": "writedown.util", "qualname": "reading_time_str", "type": "function", "doc": "<p>Returns a formatted string in the form of h:mm:ss for the supplied reading time tuple (hours, minutes, seconds).</p>\n", "signature": "(reading_time: Tuple[int, int, int]) -> str", "funcdef": "def"}, {"fullname": "writedown.version", "modulename": "writedown.version", "type": "module", "doc": "<p></p>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();